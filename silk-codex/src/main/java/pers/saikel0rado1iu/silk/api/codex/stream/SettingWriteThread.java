/*
 * This file is part of Silk API.
 * Copyright (C) 2023 Saikel Orado Liu
 *
 * Silk API is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
 *
 * Silk API is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with Silk API. If not, see <https://www.gnu.org/licenses/>.
 */

package pers.saikel0rado1iu.silk.api.codex.stream;

import com.electronwill.nightconfig.core.Config;
import com.electronwill.nightconfig.core.UnmodifiableCommentedConfig;
import com.electronwill.nightconfig.json.JsonFormat;
import com.electronwill.nightconfig.toml.TomlFormat;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import org.apache.commons.lang3.concurrent.BasicThreadFactory;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.AttributesImpl;
import pers.saikel0rado1iu.silk.api.codex.SettingData;
import pers.saikel0rado1iu.silk.api.codex.SettingOption;
import pers.saikel0rado1iu.silk.api.modpass.ModData;
import pers.saikel0rado1iu.silk.impl.SilkCodex;

import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.sax.TransformerHandler;
import javax.xml.transform.stream.StreamResult;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.nio.file.Path;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.function.BiConsumer;

/**
 * <h2 style="color:FFC800">设置写入线程</h2>
 * 以更不会影响玩家操作的方法写入设置文件
 *
 * @author <a href="https://github.com/Saikel-Orado-Liu"><img alt="author" src="https://avatars.githubusercontent.com/u/88531138?s=64&v=4"></a>
 * @since 1.0.0
 */
final class SettingWriteThread extends Thread {
	private static final ScheduledExecutorService SETTING_STORE_POOL = new ScheduledThreadPoolExecutor(1, new BasicThreadFactory.Builder().daemon(true).build());
	private final BiConsumer<Path, Iterable<? extends CharSequence>> writer;
	private final SettingData settingData;
	private final Path path;
	
	private SettingWriteThread(SettingData settingData, Path path, BiConsumer<Path, Iterable<? extends CharSequence>> writer) {
		this.settingData = settingData;
		this.path = path;
		this.writer = writer;
	}
	
	static void run(SettingData settingData, Path path, String fileName, BiConsumer<Path, Iterable<? extends CharSequence>> writer) {
		SETTING_STORE_POOL.schedule(new SettingWriteThread(settingData, Path.of(path.toString(), fileName), writer), 0, TimeUnit.SECONDS);
	}
	
	private static List<String> additionalInfo(SettingData data) {
		ModData modData = data.modData();
		ArrayList<String> list = Lists.newArrayListWithExpectedSize(8);
		list.add(String.format("This setting file is generated by %s calling %s", modData.debugName(), SilkCodex.getInstance().modData().name()));
		String separator = File.separator.contains("\\") ? "\\\\" : File.separator;
		String[] paths = modData.mod().getOrigin().getPaths().get(0).toString().split(separator);
		list.add("Mod Jar:      " + paths[paths.length - 1]);
		list.add("Mod Name:     " + modData.name());
		list.add("Mod ID:       " + modData.id());
		list.add("Mod Version:  " + modData.version());
		list.add("Mod Authors:  " + String.join(", ", modData.authors()));
		list.add("Mod Licenses: " + String.join(", ", modData.licenses()));
		if (modData.link(ModData.LinkType.HOMEPAGE).isPresent()) {
			list.add("Mod HomePage: " + modData.link(ModData.LinkType.HOMEPAGE).get());
		}
		list.add("Stored in " + LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy.MM.dd-HH:mm:ss")));
		return list;
	}
	
	private static LinkedProperties getProperties(SettingData data, String keyPrefix) {
		LinkedProperties properties = new LinkedProperties();
		LinkedHashMap<SettingOption<?>, Object[]> settingOptions = data.options();
		for (SettingOption<?> option : settingOptions.keySet()) {
			String fullKey = keyPrefix.isEmpty() ? option.id().toString() : String.format("%s.%s", keyPrefix, option.id());
			Object value = data.getValue(option);
			if (value instanceof SettingData settingData) properties.put(fullKey, getProperties(settingData, fullKey));
			else properties.put(fullKey, value.toString());
		}
		return properties;
	}
	
	private static TransformerHandler getXml(SettingData data, TransformerHandler handler, AttributesImpl attr) throws SAXException {
		LinkedHashMap<SettingOption<?>, Object[]> settingOptions = data.options();
		for (SettingOption<?> option : settingOptions.keySet()) {
			handler.startElement("", "", option.id().toString(), attr);
			Object value = data.getValue(option);
			if (value instanceof SettingData settingData) handler = getXml(settingData, handler, attr);
			else handler.characters(value.toString().toCharArray(), 0, value.toString().length());
			handler.endElement("", "", option.id().toString());
		}
		return handler;
	}
	
	private static void writeProperties(SettingData settingData, Path path, BiConsumer<Path, Iterable<? extends CharSequence>> writer) {
		writeProperties(settingData, Optional.empty(), path, writer);
	}
	
	private static List<String> writeProperties(SettingData settingData, Optional<LinkedProperties> linkedProperties, Path path, BiConsumer<Path, Iterable<? extends CharSequence>> writer) {
		ArrayList<String> info = Lists.newArrayList();
		LinkedProperties properties;
		boolean isRoot = false;
		if (linkedProperties.isEmpty()) {
			isRoot = true;
			info.addAll(additionalInfo(settingData));
			info.replaceAll(s -> "# " + s);
			properties = getProperties(settingData, "");
		} else {
			properties = linkedProperties.get();
		}
		info.add("");
		Object prevValue = null;
		for (String key : properties.linkedSet()) {
			if (prevValue instanceof LinkedProperties) info.add("");
			prevValue = properties.get(key);
			if (prevValue instanceof LinkedProperties ppt) info.addAll(writeProperties(settingData, Optional.of(ppt), path, writer));
			else if (prevValue instanceof String string) info.add(String.format("%s = %s", key.replaceAll(":", "|"), string));
			
		}
		if (isRoot) writer.accept(path, info);
		return info;
	}
	
	private static void writeXml(SettingData settingData, Path path, BiConsumer<Path, Iterable<? extends CharSequence>> writer) {
		try {
			SAXTransformerFactory xtf = (SAXTransformerFactory) SAXTransformerFactory.newInstance();
			TransformerHandler handler = xtf.newTransformerHandler();
			Transformer transformer = handler.getTransformer();
			transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
			transformer.setOutputProperty(OutputKeys.INDENT, "yes");
			transformer.setOutputProperty(OutputKeys.ENCODING, "utf-8");
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			Result result = new StreamResult(baos);
			handler.setResult(result);
			AttributesImpl attr = new AttributesImpl();
			StringBuilder info = new StringBuilder("\n");
			for (String s : additionalInfo(settingData)) info.append(s).append("\n");
			handler.startDocument();
			handler.comment(info.toString().toCharArray(), 0, info.length());
			handler.startElement("", "", settingData.modData().id(), attr);
			handler = getXml(settingData, handler, attr);
			handler.endElement("", "", settingData.modData().id());
			handler.endDocument();
			List<String> data = Arrays.asList(baos.toString().split("><"));
			data.replaceAll(s -> s.toCharArray()[0] != '<' ? "<" + s : s);
			data.replaceAll(s -> (s.toCharArray()[s.length() - 1] != '>' && s.toCharArray()[s.length() - 1] != '\n') ? s + ">" : s);
			writer.accept(path, data);
		} catch (TransformerConfigurationException | SAXException e) {
			SilkCodex.getInstance().logger().error(e.getLocalizedMessage());
		}
	}
	
	private static void writeJson(SettingData settingData, Path path, BiConsumer<Path, Iterable<? extends CharSequence>> writer) {
		JsonObject jsonObject = JsonParser.parseString(new Gson().toJson(transformToDataMap(settingData))).getAsJsonObject();
		Gson gson = new GsonBuilder().setPrettyPrinting().create();
		ArrayList<String> info = Lists.newArrayList(additionalInfo(settingData));
		for (int count = 0; count < info.size(); count++) info.set(count, "  \"//" + count + "\": \"" + info.get(count) + "\",");
		info.add("  ");
		List<String> data = new ArrayList<>(List.of(gson.toJson(jsonObject).split("\n")));
		data.addAll(1, info);
		writer.accept(path, data);
	}
	
	private static void writeToml(SettingData settingData, Path path, BiConsumer<Path, Iterable<? extends CharSequence>> writer) {
		Config.setInsertionOrderPreserved(true);
		UnmodifiableCommentedConfig config = convertConfigFormat(JsonFormat.fancyInstance().createParser().parse(new Gson().toJson(transformToDataMap(settingData))));
		ArrayList<String> info = Lists.newArrayList(additionalInfo(settingData));
		info.replaceAll(s -> "# " + s);
		info.add("");
		info.add(TomlFormat.instance().createWriter().writeToString(config));
		writer.accept(path, info);
	}
	
	private static UnmodifiableCommentedConfig convertConfigFormat(Config config) {
		Config newConfig = Config.of(TomlFormat.instance());
		for (Config.Entry entry : config.entrySet()) {
			String key = entry.getKey();
			Object value = entry.getValue();
			if (value instanceof Config) newConfig.add(key, convertConfigFormat((Config) value));
			else newConfig.add(key, value);
		}
		return UnmodifiableCommentedConfig.fake(newConfig);
	}
	
	private static LinkedHashMap<String, Object> transformToDataMap(SettingData settingData) {
		LinkedHashMap<String, Object> settingsOptions = Maps.newLinkedHashMapWithExpectedSize(10);
		for (SettingOption<?> settingOption : settingData.options().keySet()) {
			Object value = settingData.getValue(settingOption);
			if (value instanceof SettingData data) settingsOptions.put(settingOption.id().toString(), transformToDataMap(data));
			else settingsOptions.put(settingOption.id().toString(), value);
		}
		return settingsOptions;
	}
	
	@Override
	public void run() {
		while (settingData.getModifying()) Thread.yield();
		switch (settingData.format()) {
			case PROPERTIES -> writeProperties(settingData, path, writer);
			case XML -> writeXml(settingData, path, writer);
			case JSON -> writeJson(settingData, path, writer);
			case TOML -> writeToml(settingData, path, writer);
		}
	}
}
